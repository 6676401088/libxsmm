{
  "name": "LIBXSMM",
  "tagline": "Library targeting Intel Architecture (x86) for small, dense or sparse matrix multiplications, and small convolutions.",
  "body": "# [LIBXSMM](https://github.com/hfp/libxsmm/raw/master/documentation/libxsmm.pdf)\r\n[![License](https://img.shields.io/badge/license-BSD3-blue.svg)](LICENSE) [![Travis CI](https://travis-ci.org/hfp/libxsmm.svg?branch=master \"Master branch build status\")](https://github.com/hfp/libxsmm/archive/master.zip) [![Travis Mirror](https://badge.buildkite.com/63b5dc4095f460f1c011ae782f8e67ec0b8a6a9732d8abe3c7.svg)](https://buildkite.com/intel/travis-mirror \"Build status\")\r\n\r\nLIBXSMM is a library for small dense and small sparse matrix-matrix multiplications as well as for deep learning primitives such as small convolutions targeting Intel Architecture (x86). The library is generating code for the following instruction set extensions: Intel&#160;SSE, Intel&#160;AVX, Intel&#160;AVX2, IMCI (KNCni) for Intel&#160;Xeon&#160;Phi coprocessors (\"KNC\"), and Intel&#160;AVX&#8209;512 as found in the [Intel&#160;Xeon&#160;Phi processor family&#160;(\"KNL\")](https://software.intel.com/en-us/articles/what-disclosures-has-intel-made-about-knights-landing) and future Intel&#160;Xeon processors. Small convolutions are currently only optimized for Intel&#160;AVX&#8209;512. Historically the library was solely targeting the Intel&#160;Many Integrated Core Architecture \"MIC\") using intrinsic functions, meanwhile optimized assembly code is targeting all aforementioned instruction set extensions (static code generation), and Just&#8209;In&#8209;Time (JIT) code generation is targeting Intel&#160;AVX and beyond.\r\n\r\n**What is the background of the name \"LIBXSMM\"?** The \"MM\" stands for Matrix Multiplication, and the \"S\" clarifies the working domain i.e., Small Matrix Multiplication. The latter also means the name is neither a variation of \"MXM\" nor an eXtreme Small Matrix Multiplication but rather about Intel Architecture (x86) - and no, the library is [64&#8209;bit only](https://github.com/hfp/libxsmm/issues/103#issuecomment-256887962). The spelling of the name might follow the syllables of libx\\\\/smm, libx'smm, or libx&#8209;smm.\r\n\r\n**What is a small matrix multiplication?** When characterizing the problem size using the M, N, and K parameters, a problem size suitable for LIBXSMM falls approximately within (M&#160;N&#160;K)<sup>1/3</sup>&#160;\\<=&#160;80 (which illustrates that non-square matrices or even \"tall and skinny\" shapes are covered as well). The library is typically used to generate code up to the specified [threshold](#auto-dispatch). Raising the threshold may not only generate excessive amounts of code (due to unrolling in M and K dimension), but also miss to implement a tiling scheme to effectively utilize the cache hierarchy. For auto-dispatched problem sizes above the configurable threshold, LIBXSMM is falling back to BLAS.\r\n\r\n**What about \"medium-sized\" matrix multiplication?** A more recent addition are GEMM routines which are parallelized using OpenMP (`libxsmm_?gemm_omp`). These routines leverage the same specialized kernel routines as the small matrix multiplications, in-memory code generation (JIT), and automatic code/parameter dispatch but they are implementing a tile-based multiplication scheme i.e., a scheme suitable for larger problem sizes.\r\n\r\n**How to determine whether an application can benefit from using LIBXSMM or not?** Given the application uses BLAS to carry out matrix multiplications, one may use the [Call Wrapper](#call-wrapper), and measure the application performance e.g., time to solution. However, the latter can significantly improve when using LIBXSMM's API directly. To check whether there are applicable GEMM-calls, the [Verbose Mode](#verbose-mode) can help to collect an insight. Further, when an application uses [Intel&#160;MKL&#160;11.2](https://registrationcenter.intel.com/en/forms/?productid=2558) (or higher), then running the application with the environment variable MKL_VERBOSE=1 (`env MKL_VERBOSE=1 ./workload > verbose.txt`) can collect a similar insight (`grep -a \"MKL_VERBOSE DGEMM(N,N\" verbose.txt | cut -d'(' -f2 | cut -d, -f3-5\"`).\r\n\r\n**What is a small convolution?** In the last years, new workloads such as deep learning and more specifically convolutional neural networks (CNN) emerged, and are pushing the limits of today's hardware. One of the expensive kernels is a small convolution with certain kernel sizes (3, 5, or 7) such that calculations in the frequency space is not the most efficient method when compared with direct convolutions. LIBXSMM's current support for convolutions aims for an easy to use invocation of small (direct) convolutions, which are intended for CNN training and classification. The [Interface](#interface-for-convolutions) is currently ramping up, and the functionality increases quickly towards a broader set of use cases.\r\n\r\n## Interface for Matrix Multiplication\r\nThe interface of the library is *generated* according to the [Build Instructions](#build-instructions), and it is therefore **not** stored in the code repository. Instead, one may have a look at the code generation template files for [C/C++](https://github.com/hfp/libxsmm/blob/master/src/template/libxsmm.h) and [FORTRAN](https://github.com/hfp/libxsmm/blob/master/src/template/libxsmm.f).\r\n\r\nIn order to initialize the dispatch-table or other internal resources, an explicit initialization routine helps to avoid lazy initialization overhead when calling LIBXSMM for the first time. The library deallocates internal resources at program exit, but also provides a companion to the aforementioned initialization (finalize).\r\n\r\n```C\r\n/** Initialize the library; pay for setup cost at a specific point. */\r\nvoid libxsmm_init(void);\r\n/** De-initialize the library and free internal memory (optional). */\r\nvoid libxsmm_finalize(void);\r\n```\r\n\r\nTo perform the dense matrix-matrix multiplication *C<sub>m&#8239;x&#8239;n</sub> = alpha &middot; A<sub>m&#8239;x&#8239;k</sub> &middot; B<sub>k&#8239;x&#8239;n</sub> + beta &middot; C<sub>m&#8239;x&#8239;n</sub>*, the full-blown GEMM interface can be treated with \"default arguments\" (which is deviating from the LAPACK/BLAS standard, however without compromising the binary compatibility).\r\n\r\n```C\r\n/** Automatically dispatched dense matrix multiplication (single/double-precision, C code). */\r\nlibxsmm_?gemm(NULL/*transa*/, NULL/*transb*/, &m/*required*/, &n/*required*/, &k/*required*/,\r\n  NULL/*alpha*/, a/*required*/, NULL/*lda*/, b/*required*/, NULL/*ldb*/,\r\n  NULL/*beta*/, c/*required*/, NULL/*ldc*/);\r\n/** Automatically dispatched dense matrix multiplication (C++ code). */\r\nlibxsmm_gemm(NULL/*transa*/, NULL/*transb*/, m/*required*/, n/*required*/, k/*required*/,\r\n  NULL/*alpha*/, a/*required*/, NULL/*lda*/, b/*required*/, NULL/*ldb*/,\r\n  NULL/*beta*/, c/*required*/, NULL/*ldc*/);\r\n```\r\n\r\nFor the C interface (with type prefix 's' or 'd'), all arguments and in particular m, n, and k are passed by pointer. This is needed for binary compatibility with the original GEMM/BLAS interface. The C++ interface is also supplying overloaded versions where m, n, and k are allowed to be passed by&#8209;value (making it clearer that m, n, and k are non-optional arguments).\r\n\r\nThe FORTRAN interface supports optional arguments (without affecting the binary compatibility with the original LAPACK/BLAS interface) by allowing to omit arguments where the C/C++ interface allows for NULL to be passed.\r\n\r\n```FORTRAN\r\n! Automatically dispatched dense matrix multiplication (single/double-precision).\r\nCALL libxsmm_?gemm(m=m, n=n, k=k, a=a, b=b, c=c)\r\n! Automatically dispatched dense matrix multiplication (generic interface).\r\nCALL libxsmm_gemm(m=m, n=n, k=k, a=a, b=b, c=c)\r\n```\r\n\r\nFor convenience, a BLAS-based dense matrix multiplication (`libxsmm_blas_gemm`) is provided for all supported languages which is simply re-exposing the underlying GEMM/BLAS implementation. The BLAS-based GEMM might be useful for validation/benchmark purposes, and more important as a fallback when building an application-specific dispatch mechanism.\r\n\r\n```C\r\n/** Automatically dispatched dense matrix multiplication (single/double-precision). */\r\nlibxsmm_blas_?gemm(NULL/*transa*/, NULL/*transb*/, &m/*required*/, &n/*required*/, &k/*required*/,\r\n  NULL/*alpha*/, a/*required*/, NULL/*lda*/, b/*required*/, NULL/*ldb*/,\r\n  NULL/*beta*/, c/*required*/, NULL/*ldc*/);\r\n```\r\n\r\nA more recently added variant of matrix multiplication is parallelized based on the OpenMP standard. The associated routines will open an internal parallel region by default, however participating on an already opened parallel region (without relying on nested parallelism) is also possible by using the environment variable LIBXSMM_MT (0:&#160;small-sized, 1:&#160;sequential, and 2:&#160;parallelized/default). The actual parallelism is based on \"classic\" OpenMP by default (thread-based), but can be adjusted to OpenMP&#160;3.0 task-based parallelism (environment variable LIBXSMM_TASKS=1). At least the latter parallelization is dynamically scheduled. Please note that these routines are hosted by the extension library (libxsmmext) keeping the main library agnostic with respect to a particular threading runtime.\r\n\r\n```C\r\n/** OpenMP parallelized dense matrix multiplication (single/double-precision). */\r\nlibxsmm_?gemm_omp(&transa, &transb, &m, &n, &k, &alpha, a, &lda, b, &ldb, &beta, c, &ldc);\r\n```\r\n\r\nSuccessively calling a particular kernel (i.e., multiple times) allows for amortizing the cost of the code dispatch. Moreover, in order to customize the dispatch mechanism, one can rely on the following interface.\r\n\r\n```C\r\n/** If non-zero function pointer is returned, call (*function_ptr)(a, b, c). */\r\nlibxsmm_smmfunction libxsmm_smmdispatch(int m, int n, int k,\r\n  const int* lda, const int* ldb, const int* ldc,\r\n  const float* alpha, const float* beta,\r\n  const int* flags, const int* prefetch);\r\n/** If non-zero function pointer is returned, call (*function_ptr)(a, b, c). */\r\nlibxsmm_dmmfunction libxsmm_dmmdispatch(int m, int n, int k,\r\n  const int* lda, const int* ldb, const int* ldc,\r\n  const double* alpha, const double* beta,\r\n  const int* flags, const int* prefetch);\r\n```\r\n\r\nA variety of overloaded function signatures is provided allowing to omit arguments not deviating from the configured defaults. In C++, a type `libxsmm_mmfunction<type>` can be used to instantiate a functor rather than making a distinction for the numeric type in `libxsmm_?mmdispatch`. Similarly in FORTRAN, when calling the generic interface (`libxsmm_mmdispatch`) the given `LIBXSMM_?MMFUNCTION` is dispatched such that `libxsmm_call` can be used to actually perform the function call using the PROCEDURE POINTER wrapped by `LIBXSMM_?MMFUNCTION`. Beside of dispatching code, one can also call a specific kernel (e.g., `libxsmm_dmm_4_4_4`) using the prototype functions included for statically generated kernels.\r\n\r\n## Interface for Convolutions\r\nIn order to achieve best performance with small convolutions for CNN on SIMD architectures, a specific data layout has to be used. As this layout depends on several architectural parameters, the goal of LIBXSMM interface is to hide this complexity from the user by providing copy-in and copy-out routines. These happen on custom datatype which themselves are later bound to a convolution operation. The interface is available for C.\r\n\r\nThe main concept in LIBXSMM's frontend is that everything is circled around `libxsmm_dnn_conv_handle` which will define all properties of a layer operation. A handle can be created by describing the convolutional layer and calling a create function:\r\n\r\n```C\r\n/** simplified LIBXSMM types which are needed to create a handle */\r\n\r\n/** Structure which describes the input and output of data (DNN). */\r\ntypedef struct LIBXSMM_RETARGETABLE libxsmm_dnn_conv_desc {\r\n  int N;                                       /* number of images in mini-batch */\r\n  int C;                                       /* number of input feature maps */\r\n  int H;                                       /* height of input image */\r\n  int W;                                       /* width of input image */\r\n  int K;                                       /* number of output feature maps */\r\n  int R;                                       /* height of filter kernel */\r\n  int S;                                       /* width of filter kernel */\r\n  int u;                                       /* vertical stride */\r\n  int v;                                       /* horizontal stride */\r\n  int pad_h_in;                                /* height of zero-padding in input buffer, ignored */\r\n  int pad_w_in;                                /* width of zero-padding in input buffer, ignored */\r\n  int pad_h_out;                               /* height of zero-padding in output buffer */\r\n  int pad_w_out;                               /* width of zero-padding in output buffer */\r\n  libxsmm_dnn_conv_algo algo;                  /* convolution algorithm used */\r\n  libxsmm_dnn_conv_format buffer_format;       /* format which is for buffer buffers */\r\n  libxsmm_dnn_conv_format filter_format;       /* format which is for filter buffers */\r\n  libxsmm_dnn_conv_fuse_ops fuse_ops;          /* used ops into convolutions */\r\n  libxsmm_dnn_datatype datatype;               /* datatypes use for all buffers */\r\n} libxsmm_dnn_conv_desc;\r\n\r\n/** Type of algorithm used for convolutions. */\r\ntypedef enum libxsmm_dnn_conv_algo {\r\n  /** direct convolution. */\r\n  LIBXSMM_DNN_CONV_ALGO_DIRECT\r\n} libxsmm_dnn_conv_algo;\r\n\r\n/** Denotes the element/pixel type of an image/channel. */\r\ntypedef enum libxsmm_dnn_conv_datatype {\r\n  LIBXSMM_DNN_DATATYPE_F32\r\n} libxsmm_dnn_datatype;\r\n\r\nLIBXSMM_API libxsmm_dnn_conv_handle* libxsmm_dnn_create_conv_handle_check(\r\n  libxsmm_dnn_conv_desc   conv_desc,\r\n  libxsmm_dnn_datatype    conv_datatype,\r\n  libxsmm_dnn_conv_algo   conv_algo,\r\n  libxsmm_dnn_err_t*      status);\r\n```\r\n\r\nTherefore, a sample call looks like:\r\n```C\r\n/** Macro to check for an error. */\r\n#define CHKERR_LIBXSMM_DNN(A) if (A != LIBXSMM_DNN_SUCCESS) \\\r\n  fprintf(stderr, \"%s\\n\", libxsmm_dnn_get_error(A));\r\n/* declare LIBXSMM variables */\r\nlibxsmm_dnn_conv_desc conv_desc;\r\nlibxsmm_dnn_err_t status;\r\nlibxsmm_dnn_conv_handle* libxsmm_handle;\r\n/* setting conv_desc values.... */\r\nconv_desc.N = ...\r\n/* create handle */\r\nlibxsmm_handle = libxsmm_dnn_create_conv_handle_check(conv_desc, &status);\r\nCHKERR_LIBXSMM_DNN(status);\r\n```\r\n\r\nNext activation and filter buffers need to be created, initialized and bound to the handle. Afterwards the convolution could be executed by a threading environment of choice:\r\n\r\n```C\r\nlibxsmm_dnn_buffer* libxsmm_input;\r\nlibxsmm_dnn_buffer* libxsmm_output;\r\nlibxsmm_dnn_filter* libxsmm_filter;\r\n\r\n/* setup LIBXSMM layer information */\r\nlibxsmm_input = libxsmm_dnn_create_input_buffer_check(libxsmm_handle, &status);\r\nCHKERR_LIBXSMM_DNN(status);\r\nlibxsmm_output = libxsmm_dnn_create_output_buffer_check(libxsmm_handle, &status);\r\nCHKERR_LIBXSMM_DNN(status);\r\nlibxsmm_filter = libxsmm_dnn_create_filter_check(libxsmm_handle, &status);\r\nCHKERR_LIBXSMM_DNN(status);\r\n\r\n/* copy in data to LIBXSMM format: naive format is: */\r\n/* (mini-batch)(number-featuremaps)(featuremap-height)(featuremap-width) for layers, */\r\n/* and the naive format for filters is: */\r\n/* (number-output-featuremaps)(number-input-featuremaps)(kernel-height)(kernel-width) */\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_copyin_buffer(libxsmm_input, (void*)naive_input));\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_zero_buffer(libxsmm_output));\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_copyin_filter(libxsmm_filter, (void*)naive_filter));\r\n\r\n/* bind layer to handle */\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_bind_input_buffer(libxsmm_handle, libxsmm_input));\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_bind_output_buffer(libxsmm_handle, libxsmm_output));\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_bind_filter(libxsmm_handle, libxsmm_filter));\r\n\r\n/* run the convolution */\r\n#pragma omp parallel\r\n{\r\n  CHKERR_LIBXSMM_DNN(libxsmm_dnn_convolve_st(libxsmm_handle, LIBXSMM_DNN_CONV_KIND_FWD, 0,\r\n    omp_get_thread_num(), omp_get_num_threads()));\r\n}\r\n\r\n/* copy out data */\r\nCHKERR_LIBXSMM_DNN(libxsmm_dnn_copyout_buffer(libxsmm_output, (void*)naive_libxsmm_output));\r\n```\r\n\r\n## Build Instructions\r\nThe build system relies on GNU Make (typically associated with the `make` command, but e.g. FreeBSD is calling it `gmake`). The build can be customized by using key&#8209;value pairs. Key&#8209;value pairs can be supplied in two ways: (1)&#160;after the \"make\" command, or (2)&#160;prior to the \"make\" command (`env`) which is effectively the same as exporting the key&#8209;value pair as an environment variable (`export`, or `setenv`). Of course both methods can be mixed, however the second method may require to supply the `-e` flag. Please note that the CXX, CC, and FC keys are handled such that they are taken into account in any case.\r\n\r\nTo generate the interface of the library inside of the 'include' directory and to build the static library (by default, STATIC=1 is activated), simply run the following command:\r\n\r\n```\r\nmake\r\n```\r\n\r\nIf the build process is not successful, it may help to avoid more advanced GCC flags. This is useful with a tool chain, which pretends to be GCC-compatible (or is treated as such) but actually fails to consume the aforementioned flags. In such a case (CCE, etc.) one may raise the compatibility:\r\n\r\n```\r\nmake COMPATIBLE=1\r\n```\r\n\r\nBy default, only the non-coprocessor targets are built (OFFLOAD=0 and KNC=0). In general, the subfolders of the 'lib' directory are separating the build targets where the 'mic' folder is containing the native library (KNC=1) targeting the Intel&#160;Xeon&#160;Phi coprocessor (\"KNC\"), and the 'intel64' folder is storing either the hybrid archive made of CPU and coprocessor code (OFFLOAD=1), or an archive which is only containing the CPU code. By default, an OFFLOAD=1 implies KNC=1.\r\n\r\nTo remove intermediate files, or to remove all generated files and folders (including the interface and the library archives), run one of the following commands:\r\n\r\n```\r\nmake clean\r\nmake realclean\r\n```\r\n\r\nBy default, LIBXSMM uses the [JIT backend](#jit-backend) which is automatically building optimized code. However, one can also statically specialize for particular matrix sizes (M, N, and K values), for convolutions the options below can be ignored:\r\n\r\n```\r\nmake M=\"2 4\" N=\"1\" K=\"$(echo $(seq 2 5))\"\r\n```\r\n\r\nThe above example is generating the following set of (M,N,K) triplets:\r\n\r\n```\r\n(2,1,2), (2,1,3), (2,1,4), (2,1,5),\r\n(4,1,2), (4,1,3), (4,1,4), (4,1,5)\r\n```\r\n\r\nThe index sets are in a loop-nest relationship (M(N(K))) when generating the indices. Moreover, an empty index set resolves to the next non-empty outer index set of the loop nest (including to wrap around from the M to K set). An empty index set is not participating anymore in the loop-nest relationship. Here is an example of generating multiplication routines which are \"squares\" with respect to M and N (N inherits the current value of the \"M loop\"):\r\n\r\n```\r\nmake M=\"$(echo $(seq 2 5))\" K=\"$(echo $(seq 2 5))\"\r\n```\r\n\r\nAn even more flexible specialization is possible by using the MNK variable when building the library. It takes a list of indexes which are eventually grouped (using commas):\r\n\r\n```\r\nmake MNK=\"2 3, 23\"\r\n```\r\n\r\nEach group of the above indexes is combined into all possible triplets generating the following set of (M,N,K) values:\r\n\r\n```\r\n(2,2,2), (2,2,3), (2,3,2), (2,3,3),\r\n(3,2,2), (3,2,3), (3,3,2), (3,3,3), (23,23,23)\r\n```\r\n\r\nOf course, both mechanisms (M/N/K and MNK based) can be combined using the same command line (make). Static optimization and JIT can also be combined (no need to turn off the JIT backend). Testing the library is supported by a variety of targets with \"test\" and \"test-all\" being the most prominent for this matter.\r\n\r\nFunctionality of LIBXSMM, which is unrelated to GEMM can be used without introducing a dependency to LAPACK/BLAS. This can be achieved in two ways: (1)&#160;building a special library with `make BLAS=0`, or (2)&#160;linking the application against the 'libxsmmnoblas' library. Some care must be taken with any matrix multiplication which does not appear to require BLAS for the given test arguments. However, it may fall back to BLAS (at runtime of the application), if an unforeseen input is given (problem size, or unsupported GEMM arguments).\r\n\r\n**NOTE**: by default, a C/C++ and a FORTRAN compiler is needed (some sample code is written in C++). Beside of specifying the compilers (`make CXX=g++ CC=gcc FC=gfortran` and maybe `AR=ar`), the need for a FORTRAN compiler can be relaxed (`make FC=` or `make FORTRAN=0`). The latter affects the availability of the MODule file and the corresponding 'libxsmmf' library (the interface 'libxsmm.f' is still generated). FORTRAN code can make use of LIBXSMM in three different ways:\r\n\r\n* By relying on the module file, and by linking against 'libxsmmf', 'libxsmm', and (optionally) 'libxsmmext',\r\n* By including the interface 'libxsmm.f' and linking against 'libxsmm', and (optionally) 'libxsmmext', or\r\n* By declaring e.g., `libxsmm_?gemm` (BLAS signature) and linking 'libxsmm' (and 'libxsmmext' if needed).\r\n\r\nAt the expense of a limited set of functionality (`libxsmm_?gemm[_omp]`, `libxsmm_blas_?gemm`, and `libxsmm_[s|d]otrans[_omp]`), the latter method also works with FORTRAN&#160;77 (otherwise the FORTRAN&#160;2003 standard is necessary). For the \"omp\" functionality, the 'libxsmmext' library needs to be present at the link line. For no code change at all, the [Call Wrapper](#call-wrapper) might be of interest.\r\n\r\n## Installation\r\nInstalling LIBXSMM makes possibly the most sense when combining the [JIT backend](#jit-backend) (enabled by default) with a collection of statically generated SSE kernels (by specifying M, N, K, or MNK). If the JIT backend is not disabled, statically generated kernels are only registered for dispatch if the CPUID flags at runtime are not supporting a more specific instruction set extension (code path). Since the JIT backend does not support or generate SSE code by itself, the library is compiled by selecting SSE code generation if not specified otherwise (AVX=1|2|3, or with SSE=0 falling back to an \"arch-native\" approach). Limiting the static code path to SSE3 (SSE4.2 under OS&#160;X) allows to practically target any deployed system, however using SSE=0 and AVX=0 together is falling back to generic code, and any static kernels are not specialized using the assembly code generator.\r\n\r\nThere are two main mechanisms to install LIBXSMM (both mechanisms can be combined): (1)&#160;building the library in an out&#8209;of&#8209;tree fashion, and (2)&#160;installing into a certain location. Building in an out&#8209;of&#8209;tree fashion looks like:\r\n\r\n```\r\ncd libxsmm-install\r\nmake -f /path/to/libxsmm/Makefile\r\n```\r\n\r\nFor example, installing into a specific location (incl. a selection of statically generated Intel&#160;SSE kernels) looks like:\r\n\r\n```\r\nmake MNK=\"1 2 3 4 5\" PREFIX=/path/to/libxsmm-install install\r\n```\r\n\r\nPerforming `make install-minimal` omits the documentation (default: 'PREFIX/share/libxsmm'). Moreover, PINCDIR, POUTDIR, PBINDIR, and PDOCDIR allow to customize the locations underneath of the PREFIX location. To build a general package for an unpredictable audience (Linux distribution, or similar), it is advised to not over-specify or customize the build step i.e., JIT, SSE, AVX, OMP, BLAS, etc. should not be used. The following is building and installing a complete set of libraries where the generated interface matches both the static and the shared libraries:\r\n\r\n```\r\nmake PREFIX=/path/to/libxsmm-install STATIC=0 install\r\nmake PREFIX=/path/to/libxsmm-install install\r\n```\r\n\r\n**NOTE**: the library is agnostic with respect to the threading-runtime, and enabling OpenMP (OMP=1) when building the library is a non-default option (untested). The libraries are also agnostic with respect to the selected LAPACK/BLAS library (if supported by OS and link model), and therefore linking GEMM routines when building the library (by supplying BLAS=1|2) may prevent a user from deciding at the time of linking the actual application.\r\n\r\n## Running\r\n### Call Wrapper\r\nSince the library is binary compatible with existing GEMM calls (LAPACK/BLAS), these calls can be replaced at link-time or intercepted at runtime of an application such that LIBXSMM is used instead of the original LAPACK/BLAS library. There are two cases to consider:\r\n\r\n* An application which is linked statically against LAPACK/BLAS requires to wrap the 'sgemm_' and the 'dgemm_' symbol (an alternative is to wrap only 'dgemm_'), and a special build of the libxsmm(ext) library is required (`make WRAP=1` to to wrap SGEMM and DGEMM, or `make WRAP=2` to wrap only DGEMM):  \r\n`gcc [...] -Wl,--wrap=sgemm_,--wrap=dgemm_ /path/to/libxsmmext.a /path/to/libxsmm.a /path/to/your_regular_blas.a`  \r\nRelinking the application as shown above can often be accomplished by copying, pasting, modifying the linker command, and then re-invoking the modified link step. This linker command may appear as console output of the application's \"make\" command (or a similar build system).  \r\nThe static link-time wrapper technique may only work with a GCC tool chain (GNU Binutils: `ld`, or `ld` via compiler-driver), and it has been tested with GNU GCC, Intel&#160;Compiler, and Clang. However, this does not work under Microsoft Windows (even when using the GNU tool chain), and it may not work under OS&#160;X (Compiler&#160;6.1 or earlier, later versions have not been tested).\r\n* An application which is dynamically linked against LAPACK/BLAS allows for intercepting the GEMM calls at startup time (runtime) of the unmodified executable by using the LD_PRELOAD mechanism. The shared library of LIBXSMM (`make STATIC=0`) allows to intercept the GEMM calls of the application:  \r\n`LD_PRELOAD=/path/to/libxsmmext.so ./myapplication`\r\n\r\nThe behavior of the intercepted GEMM routines (statically wrapped or via LD_PRELOAD) can be controlled with the environment variable LIBXSMM_MT i.e., 0:&#160;calling sequential below-threshold routines without OpenMP (default when only linking 'libxsmm'), 1:&#160;OpenMP-parallelized behavior but without an internal parallel region, and 2:&#160;OpenMP-parallelized routines with internal parallel region (default when linking 'libxsmmext'). In any case, the wrapper mechanism also supports to fall back to BLAS.\r\n\r\n```\r\nLIBXSMM_MT=0 ./myapplication\r\n```\r\n\r\n**NOTE**: Using the same multiplication kernel in a consecutive fashion (batch-processing) allows to extract higher performance, when using LIBXSMM's native programming interface.\r\n\r\n### Verbose Mode\r\nThe verbose mode allows for an insight into the code dispatch mechanism by receiving a small tabulated statistic as soon as the library terminates. The design point for this functionality is to not impact the performance of any critical code path i.e., verbose mode is always enabled and does not require symbols (SYM=1) or debug code (DBG=1). The statistics appears (`stderr`) when the environment variable LIBXSMM_VERBOSE is set to a non-zero value. For example:\r\n\r\n```\r\nLIBXSMM_VERBOSE=1 ./myapplication\r\n[... application output]\r\n\r\nHSW/SP        TRY    JIT    STA    COL\r\n     0..13      7      7      0      0\r\n    14..23      0      0      0      0\r\n    24..80      3      3      0      0\r\n```\r\n\r\nThe tables are distinct between single-precision and double-precision, but either table is pruned if all counters are zero. If both tables are pruned, the library shows the code path which would have been used for JIT'ting the code: `LIBXSMM_TARGET=hsw` (otherwise the code path is shown in the table's header). The actual counters are collected for three buckets: small kernels (MNK<sup>1/3</sup>&#160;\\<=&#160;13), medium-sized kernels (13&#160;\\<&#160;MNK<sup>1/3</sup>&#160;\\<=&#160;23), and larger kernels (23&#160;\\<&#160;MNK<sup>1/3</sup>&#160;\\<=&#160;80; the actual upper bound depends on LIBXSMM_MAX_MNK as selected at compile-time). Keep in mind, that \"larger\" is supposedly still fairly small in terms of arithmetic intensity (which grows linearly with the kernel size). Unfortunately, the arithmetic intensity depends on the way a kernel is used (which operands are loaded/stored into main memory) and it is not performance-neutral to collect this information.\r\n\r\nThe TRY counter represents all attempts to register statically generated kernels, and all attempts to dynamically generate and register kernels. The TRY counter includes rejected JIT requests due to unsupported GEMM arguments. The JIT and STA counters distinct the successful cases of the aforementioned event (TRY) into dynamically (JIT) and statically (STA) generated code. In case the capacity (O(*n*)&#160;=&#160;10<sup>5</sup>) of the code registry is exhausted, no more kernels can be registered although further attempts are not prevented. Registering many kernels (O(*n*)&#160;=&#160;10<sup>3</sup>) may ramp the number of hash key collisions (COL), which can degrade performance. The latter is prevented if the small thread-local cache is utilized effectively.\r\n\r\nSince explicitly JIT-generated code (`libxsmm_?mmdispatch`) does not fall under the THRESHOLD criterion, the above table is extended by one line if large kernels have been requested. This indicates a missing threshold-criterion (customized dispatch), or asks for cache-blocking the matrix multiplication. The latter is already implemented by LIBXSMM's \"medium-sized\" GEMM routines (`libxsmm_?gemm_omp`), which perform a tiled multiplication.\r\n\r\n**NOTE**: setting LIBXSMM_VERBOSE to a negative value will dump each generated JIT kernel to a file with each file being named similar to the function name shown in [Intel&#160;VTune](#profiling).\r\n\r\n### Call Trace\r\nDuring the initial steps of employing the LIBXSMM API, one may rely on a debug version of the library (`make DBG=1`). The latter also implies console output (`stderr`) in case of an error/warning condition inside of the library. It is also possible to print the execution flow (call trace) inside of LIBXSMM (can be combined with DBG=1 or OPT=0):\r\n\r\n```\r\nmake TRACE=1\r\n```\r\n\r\nBuilding an application which is able to trace calls (inside of the library) requires the shared library of LIBXSMM, alternatively the application is required to link the static library of LIBXSMM in a dynamic fashion (GNU tool chain: `-rdynamic`). Actually tracing calls (without debugger) can be the accomplished by an environment variable called LIBXSMM_TRACE.\r\n\r\n```\r\nLIBXSMM_TRACE=1 ./myapplication\r\n```\r\n\r\nSyntactically up to three arguments separated by commas (which allows to omit arguments) are taken (*tid*,*i*,*n*): *tid* signifies the ID of the thread to be traced with 1...NTHREADS being valid and where LIBXSMM_TRACE=1 is filtering for the \"main thread\" (in fact the first thread running into the trace facility); grabbing all threads (no filter) can be achieved by supplying a negative id (which is also the default when omitted). The second argument is pruning higher levels of the call-tree with *i=1* being the default (level zero is the highest at the same level as the main function). The last argument is taking the number of inclusive call levels with *n=-1* being the default (signifying no filter).\r\n\r\nAlthough the `ltrace` (Linux utility) provides similar insight, the trace facility might be useful due to the aforementioned filtering expressions. Please note that the trace facility is severely impacting the performance (even with LIBXSMM_TRACE=0), and this is not just because of console output but rather since inlining (internal) functions might be prevented along with additional call overhead on each function entry and exit. Therefore, debug symbols can be also enabled separately (`make SYM=1`; implied by TRACE=1 or DBG=1) which might be useful when profiling an application. No facility of the library (other than DBG or TRACE/LIBXSMM_TRACE) is performing visible (console) or other non-private I/O (files).\r\n\r\n## Performance\r\n### Profiling\r\n#### Intel&#160;VTune&#160;Amplifier\r\nTo analyze which kind of kernels have been called, and from where these kernels have been invoked (call stack), the library allows profiling its JIT code using Intel&#160;VTune&#160;Amplifier. To enable this support, VTune's root directory needs to be set at build-time of the library. Enabling symbols (SYM=1 or DBG=1) incorporates VTune's JIT Profiling API:\r\n\r\n```\r\nsource /path/to/vtune_amplifier/amplxe-vars.sh\r\nmake SYM=1\r\n```\r\n\r\nAbove, the root directory is automatically determined from the environment (VTUNE_AMPLIFIER_\\*_DIR). This variable is present after source'ing the Intel&#160;VTune environment, but it can be manually provided as well (`make VTUNEROOT=/path/to/vtune_amplifier`). Symbols are actually not required to display kernel names for the dynamically generated code, however enabling symbols makes the analysis much more useful for the rest of the (static) code, and hence it has been made a prerequisite. For example, when \"call stacks\" are collected it is possible to find out where the JIT code has been invoked by the application:\r\n\r\n```\r\namplxe-cl -r result-directory -data-limit 0 -collect advanced-hotspots \\\r\n          -knob collection-detail=stack-sampling -- ./myapplication\r\n```\r\n\r\nIn case of an MPI-parallelized application, it might be useful to only collect results from a \"representative\" rank, and to also avoid running the event collector in every rank of the application. With Intel&#160;MPI both of the latter can be achieved by adding\r\n\r\n```\r\n-gtool 'amplxe-cl -r result-directory -data-limit 0 -collect advanced-hotspots \\\r\n                  -knob collection-detail=stack-sampling:4=exclusive'\r\n```\r\n\r\nto the `mpirun` command line. Please notice the `:4=exclusive` (unrelated to VTune's command line syntax), which is related to mpirun's gtool arguments; these arguments need to appear at the end of the gtool-string. For instance, the shown command line selects the 4th rank (otherwise all ranks are sampled) along with \"exclusive\" usage of the performance monitoring unit (PMU) such that only one event-collector runs for all ranks.\r\n\r\nIntel&#160;VTune&#160;Amplifier presents invoked JIT code like functions, which belong to a module named \"libxsmm.jit\". The function name as well as the module name are supplied by LIBXSMM using the aforementioned JIT Profiling API. For instance \"libxsmm_hsw_dnn_23x23x23_23_23_23_a1_b1_p0::smxm\" encodes an Intel&#160;AVX2 (\"hsw\") double-precision kernel (\"d\") for small dense matrix multiplications (\"smxm\") which is multiplying matrices without transposing them (\"nn\"). The rest of the name encodes M=N=K=LDA=LDB=LDC=23, Alpha=Beta=1.0 (all similar to GEMM), and no prefetch strategy (\"p0\").\r\n\r\n#### Linux perf\r\nWith LIBXSMM, there is both basic (`perf map`) and extended support (`jitdump`) when profiling an application. To enable perf support at runtime, the environment LIBXSMM_VERBOSE needs to be set to a negative value.\r\n\r\n* The basic support can be enabled at compile-time with PERF=1 (implies SYM=1) using `make PERF=1`. At runtime of the application, a map-file ('jit-*pid*.map') is generated ('/tmp' directory). This file is automatically read by Linxu perf, and enriches the information about unknown code such as JIT'ted kernels.\r\n* The support for \"jitdump\" can be enabled by supplying JITDUMP=1 (implies PERF=1) or PERF=2 (implies JITDUMP=1) when making the library: `make JITDUMP=1` or `make PERF=2`. At runtime of the application, a dump-file ('jit-*pid*.dump') is generated (in perf's debug directory, usually `$HOME/.debug/jit/`) which includes information about JIT'ted kernels (such as addresses, symbol names, code size, and the code itself). The dump file can be injected into 'perf.data' (using `perf inject -j`), and it enables an annotated view of the assembly in perf's report (requires a reasonably recent version of perf).\r\n\r\n### Tuning\r\nSpecifying a particular code path is not really necessary if the JIT backend is not disabled. However, disabling JIT compilation, statically generating a collection of kernels, and targeting a specific instruction set extension for the entire library looks like:\r\n\r\n```\r\nmake JIT=0 AVX=3 MNK=\"1 2 3 4 5\"\r\n```\r\n\r\nThe above example builds a library which cannot be deployed to anything else but the Intel&#160;Knights&#160;Landing processor family&#160;(\"KNL\") or future Intel&#160;Xeon processors supporting foundational Intel&#160;AVX&#8209;512 instructions (AVX&#8209;512F). The latter might be even more adjusted by supplying MIC=1 (along with AVX=3), however this does not matter since critical code is in inline assembly (and not affected). Similarly, SSE=0 (or JIT=0 without SSE or AVX build flag) employs an \"arch-native\" approach whereas AVX=1, AVX=2 (with FMA), and AVX=3 are specifically selecting the kind of Intel&#160;AVX code. Moreover, controlling the target flags manually or adjusting the code optimizations is also possible. The following example is GCC-specific and corresponds to OPT=3, AVX=3, and MIC=1:\r\n\r\n```\r\nmake OPT=3 TARGET=\"-mavx512f -mavx512cd -mavx512er -mavx512pf\"\r\n```\r\n\r\nAn extended interface can be generated which allows to perform software prefetches. Prefetching data might be helpful when processing batches of matrix multiplications where the next operands are farther away or otherwise unpredictable in their memory location. The prefetch strategy can be specified similar as shown in the section [Generator Driver](#generator-driver) i.e., by either using the number of the shown enumeration, or by exactly using the name of the prefetch strategy. The only exception is PREFETCH=1 which is automatically selecting a strategy according to an internal table (navigated by CPUID flags). The following example is requesting the \"AL2jpst\" strategy:\r\n\r\n```\r\nmake PREFETCH=8\r\n```\r\n\r\nThe prefetch interface is extending the signature of all kernels by three arguments (pa, pb, and pc). These additional arguments are specifying the locations of the operands of the next multiplication (the next a, b, and c matrices). Providing unnecessary arguments in case of the three-argument kernels is not big a problem (beside of some additional call-overhead), however running a kernel which is picking up more than three arguments and actually picking up garbage data is disabling the hardware prefetcher (due to software prefetches) followed by a misleading prefetch location plus an eventual page fault due to an out-of-bounds (garbage-)location.\r\n\r\nFurther, the generated configuration ([template](https://github.com/hfp/libxsmm/blob/master/src/template/libxsmm_config.h)) of the library encodes the parameters for which the library was built for (static information). This helps optimizing client code related to the library's functionality. For example, the LIBXSMM_MAX_* and LIBXSMM_AVG_* information can be used with the LIBXSMM_PRAGMA_LOOP_COUNT macro in order to hint loop trip counts when handling matrices related to the problem domain of LIBXSMM.\r\n\r\n### Auto-dispatch\r\nThe function `libxsmm_?mmdispatch` helps amortizing the cost of the dispatch when multiple calls with the same M, N, and K are needed. The automatic code dispatch is orchestrating two levels:\r\n\r\n1. Specialized routine (implemented in assembly code),\r\n2. LAPACK/BLAS library call (fallback).\r\n\r\nBoth levels are accessible directly (see [Interface](#interface) section) allowing to customize the code dispatch. The fallback level may be supplied by the Intel&#160;Math&#160;Kernel&#160;Library&#160;(Intel&#160;MKL)&#160;11.2 DIRECT CALL feature.\r\n\r\nFurther, a preprocessor symbol denotes the largest problem size (*M* x *N* x *K*) that belongs to the first level, and therefore determines if a matrix multiplication falls back to calling into the LAPACK/BLAS library alongside of LIBXSMM. The problem size threshold can be configured by using for example:\r\n\r\n```\r\nmake THRESHOLD=$((60 * 60 * 60))\r\n```\r\n\r\nThe maximum of the given threshold and the largest requested specialization refines the value of the threshold. Please note that explicitly JIT'ting and executing a kernel is possible and independent of the threshold. If a problem size is below the threshold, dispatching the code requires to figure out whether a specialized routine exists or not.\r\n\r\nIn order to minimize the probability of key collisions (code cache), the preferred precision of the statically generated code can be selected:\r\n\r\n```\r\nmake PRECISION=2\r\n```\r\n\r\nThe default preference is to generate and register both single and double-precision code, and therefore no space in the dispatch table is saved (PRECISION=0). Specifying PRECISION=1|2 is only generating and registering either single-precision or double-precision code.\r\n\r\nThe automatic dispatch is highly convenient because existing GEMM calls can serve specialized kernels (even in a binary compatible fashion), however there is (and always will be) an overhead associated with looking up the code-registry and checking whether the code determined by the GEMM call is already JIT'ted or not. This lookup has been optimized using various techniques such as using specialized CPU instructions calculating a CRC32 checksum, avoiding costly synchronization (needed for thread-safety) until it is ultimately known that the requested kernel is not yet JIT'ted, and also a small thread-local cache of recently dispatched kernels. The latter of which can be adjusted in size (only power-of-two sizes) but also disabled:\r\n\r\n```\r\nmake CACHE=0\r\n```\r\n\r\nPlease note that measuring the relative cost of automatically dispatching a requested kernel depends on the kernel size (obviously smaller matrices are multiplied faster on an absolute basis), however smaller matrix multiplications are bottlenecked by memory bandwidth rather than arithmetic intensity. The latter implies the highest relative overhead when (artificially) benchmarking the very same multiplication out of the CPU-cache.\r\n\r\n### JIT Backend\r\nThere might be situations in which it is up-front not clear which problem sizes will be needed when running an application. In order to leverage LIBXSMM's high-performance kernels, the library implements a JIT (Just-In-Time) code generation backend which generates the requested kernels on the fly (in-memory). This is accomplished by emitting the corresponding byte-code directly into an executable buffer. The actual JIT code is generated according to the CPUID flags, and therefore does not rely on the code path selected when building the library. In the current implementation, some limitations apply to the JIT backend specifically:\r\n\r\n1. In order to stay agnostic to any threading model used, Pthread mutexes are guarding the updates of the JIT'ted code cache (link line with `-lpthread` is required); building with OMP=1 employs an OpenMP critical section as an alternative locking mechanism.\r\n2. There is no support for the Intel&#160;SSE (Intel&#160;Xeon 5500/5600 series) and IMCI (Intel&#160;Xeon&#160;Phi coprocessor code-named Knights Corner) instruction set extensions. However, statically generated SSE-kernels can be leveraged without disabling support for JIT'ting AVX kernels.\r\n3. There is no support for the Windows calling convention (only kernels with PREFETCH=0 signature).\r\n\r\nThe JIT backend can also be disabled at build time (`make JIT=0`) as well as at runtime (`LIBXSMM_TARGET=0`, or anything prior to Intel&#160;AVX). The latter is an environment variable which allows to set a code path independent of the CPUID (LIBXSMM_TARGET=0|1|sse|snb|hsw|knl|skx). Please note that LIBXSMM_TARGET cannot enable the JIT backend if it was disabled at build time (JIT=0).\r\n\r\nOne can use the aforementioned THRESHOLD parameter to control the matrix sizes for which the JIT compilation will be automatically performed. However, explicitly requested kernels (by calling `libxsmm_?mmdispatch`) are not subject to a problem size threshold. In any case, JIT code generation can be used for accompanying statically generated code.\r\n\r\nNote: Modern Linux kernels are supporting transparent huge pages (THP). LIBXSMM is sanitizing this feature when setting the permissions for pages holding the executable code. However, we measured up to 30% slowdown when running JIT'ted code in cases where THP decided to deliver a huge page. For systems with Linux kernel 2.6.38 (or later) THP will be automatically disabled for the `mmap`'ed regions (using `madvise`).\r\n\r\n### Generator Driver\r\nIn rare situations it might be useful to directly incorporate generated C code (with inline assembly regions). This is accomplished by invoking a driver program (with certain command line arguments). The driver program is built as part of LIBXSMM's build process (when requesting static code generation), but also available via a separate build target:\r\n\r\n```\r\nmake generator\r\nbin/libxsmm_gemm_generator\r\n```\r\n\r\nThe code generator driver program accepts the following arguments:\r\n\r\n1. dense/dense_asm/sparse (dense creates C code, dense_asm creates ASM)\r\n2. Filename of a file to append to\r\n3. Routine name to be created\r\n4. M parameter\r\n5. N parameter\r\n6. K parameter\r\n7. LDA (0 when 1. is \"sparse\" indicates A is sparse)\r\n8. LDB (0 when 1. is \"sparse\" indicates B is sparse)\r\n9. LDC parameter\r\n10. alpha (1)\r\n11. beta (0 or 1)\r\n12. Alignment override for A (1 auto, 0 no alignment)\r\n13. Alignment override for C (1 auto, 0 no alignment)\r\n14. Architecture (noarch, wsm, snb, hsw, knc, knl, skx)\r\n15. Prefetch strategy, see below enumeration (dense/dense_asm only)\r\n16. single precision (SP), or double precision (DP)\r\n17. CSC file (just required when 1. is \"sparse\"). Matrix market format.\r\n\r\nThe prefetch strategy can be:\r\n\r\n1. \"nopf\": no prefetching at all, just 3 inputs (A, B, C)\r\n2. \"pfsigonly\": just prefetching signature, 6 inputs (A, B, C, A', B', C')\r\n3. \"BL2viaC\": uses accesses to C to prefetch B'\r\n4. \"curAL2\": prefetches current A ahead in the kernel\r\n5. \"curAL2_BL2viaC\": combines curAL2 and BL2viaC\r\n6. \"AL2\": uses accesses to A to prefetch A'\r\n7. \"AL2_BL2viaC\": combines AL2 and BL2viaC\r\n8. \"AL2jpst\": aggressive A' prefetch of first rows without any structure\r\n9. \"AL2jpst_BL2viaC\": combines AL2jpst and BL2viaC\r\n10. \"AL2_BL2viaC_CL2\": combines AL2 and BL2viaC\r\n\r\n\r\nHere are some examples of invoking the driver program:\r\n\r\n```\r\nbin/libxsmm_gemm_generator dense foo.c foo 16 16 16 32 32 32 1 1 1 1 hsw nopf DP\r\nbin/libxsmm_gemm_generator dense_asm foo.c foo 16 16 16 32 32 32 1 1 1 1 knl AL2_BL2viaC DP\r\nbin/libxsmm_gemm_generator sparse foo.c foo 16 16 16 32 0 32 1 1 1 1 hsw nopf DP bar.csc\r\n```\r\n\r\nPlease note, there are additional examples given in samples/generator and samples/seissol.\r\n\r\n### Results\r\nThe LIBXSMM repository provides an orphaned branch \"results\" which is collecting collateral material such as measured performance results along with explanatory figures. The results can be found at [https://github.com/hfp/libxsmm/tree/results#libxsmm-results](https://github.com/hfp/libxsmm/tree/results#libxsmm-results).\r\n\r\nPlease note that comparing performance results depends on whether or not streaming the operands of the matrix multiplication. For example, running a matrix multiplication code many time with all operands covered by the L1 cache may have an emphasis towards an implementation which actually performs worse for the real workload (if this real workload needs to stream some or all operands from the main memory).\r\n\r\n## Contributions\r\nContributions are very welcome! Please visit [https://github.com/hfp/libxsmm/wiki/Contribute](https://github.com/hfp/libxsmm/wiki/Contribute).\r\n\r\n## Applications\r\n**\\[1]&#160;[https://cp2k.org/](https://cp2k.org/)**: Open Source Molecular Dynamics with its DBCSR component processing batches of small matrix multiplications (\"matrix stacks\") out of a problem-specific distributed block-sparse matrix. Starting with [CP2K 3.0](https://www.cp2k.org/version_history), LIBXSMM can be used to substitute CP2K's 'libsmm' library. Prior to CP2K 3.0, only the [Intel-branch of CP2K](https://github.com/cp2k/cp2k/tree/intel) was integrating LIBXSMM (see https://github.com/hfp/libxsmm/raw/master/documentation/cp2k.pdf).\r\n\r\n**\\[2]&#160;[https://github.com/SeisSol/SeisSol/](https://github.com/SeisSol/SeisSol/)**: SeisSol is one of the leading codes for earthquake scenarios, in particular for simulating dynamic rupture processes. LIBXSMM provides highly optimized assembly kernels which form the computational back-bone of SeisSol (see https://github.com/TUM-I5/seissol_kernels/).\r\n\r\n**\\[3]&#160;[https://github.com/Nek5000/NekBox](https://github.com/Nek5000/NekBox)**: NekBox is a version of the highly scalable and portable spectral element [Nek5000](https://nek5000.mcs.anl.gov/) code which is specialized for box geometries, and intended for prototyping new methods as well as leveraging FORTRAN beyond the FORTRAN&#160;77 standard. LIBXSMM provides optimized kernels aiming to conveniently substitute the [MXM_STD](https://github.com/Nek5000/NekBox/blob/box/mxm_std.F90) code.\r\n\r\n**\\[4]&#160;[https://github.com/Nek5000/Nek5000](https://github.com/Nek5000/Nek5000)**: Nek5000 is the open-source, highly-scalable, always-portable spectral element code from [https://nek5000.mcs.anl.gov/](https://nek5000.mcs.anl.gov/). The development branch of the Nek5000 code now [incorporates](https://github.com/Nek5000/Nek5000/blob/develop/core/mxm_wrapper.f) LIBXSMM.\r\n\r\n**\\[5]&#160;[https://software.intel.com/en-us/articles/intel-xeon-phi-delivers-competitive-performance-for-deep-learning-and-getting-better-fast](https://software.intel.com/en-us/articles/intel-xeon-phi-delivers-competitive-performance-for-deep-learning-and-getting-better-fast)**: Intel Xeon Phi Delivers Competitive Performance For Deep Learning - And Getting Better Fast. Article mentioning LIBXSMM's performance of convolution kernels with DeepBench. Intel Corporation, 2016.\r\n\r\n## References\r\n**\\[1]&#160;[http://sc16.supercomputing.org/presentation/?id=pap364&sess=sess153](http://sc16.supercomputing.org/presentation/?id=pap364&sess=sess153)**: LIBXSMM: Accelerating Small Matrix Multiplications by Runtime Code Generation (accepted full paper). SC'16: The International Conference for High Performance Computing, Networking, Storage and Analysis, Salt Lake City (Utah).\r\n\r\n**\\[2]&#160;[http://sc15.supercomputing.org/sites/all/themes/SC15images/tech_poster/tech_poster_pages/post137.html](http://sc15.supercomputing.org/sites/all/themes/SC15images/tech_poster/tech_poster_pages/post137.html)**: LIBXSMM: A High Performance Library for Small Matrix Multiplications (poster and two-page extended abstract). SC'15: The International Conference for High Performance Computing, Networking, Storage and Analysis, Austin (Texas).\r\n",
  "google": "UA-65670560-2",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}